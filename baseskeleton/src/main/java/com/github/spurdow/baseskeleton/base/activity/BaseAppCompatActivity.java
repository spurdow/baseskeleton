package com.github.spurdow.baseskeleton.base.activity;

import android.os.Bundle;
import android.support.annotation.LayoutRes;
import android.support.annotation.Nullable;
import android.support.v7.app.ActionBar;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.MenuItem;
import android.view.View;
import android.view.WindowManager;


import com.github.spurdow.baseskeleton.R;
import com.github.spurdow.baseskeleton.base.callbacks.OnToolbarTextChange;

import java.util.HashMap;
import java.util.Map;

import butterknife.BindView;
import butterknife.ButterKnife;

/**
 * Created by davidluvellejoseph on 8/18/16.
 */
public abstract class BaseAppCompatActivity extends AppCompatActivity implements OnToolbarTextChange {

    private static final String TAG = BaseAppCompatActivity.class.getSimpleName();
    @Nullable
    @BindView(R.id.toolbar)
    protected Toolbar mToolbar;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(resourceId());
        ButterKnife.bind(this);

        if(fullScreen()){
            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                    WindowManager.LayoutParams.FLAG_FULLSCREEN);
        }


        if(mToolbar != null ){
            setSupportActionBar(mToolbar);
        }


        if (hideToolBar() ) {
            if( mToolbar != null){
                mToolbar.setVisibility(View.GONE);
            }else{
                ActionBar mActionBar = getSupportActionBar();
                if(mActionBar != null) {
                    mActionBar.hide();
                }
            }
        }

        ActionBar mActionBar = getSupportActionBar();
        if(mActionBar != null) {
            mActionBar.setDisplayShowTitleEnabled(displayTitle());
            mActionBar.setDisplayHomeAsUpEnabled(displayHomeUp());
            mActionBar.setHomeButtonEnabled(homeButton());
        }

        provideBundleExtra(savedInstanceState);
        provideSetUp(savedInstanceState);
        setTitle(provideTitle());
        if(hideKeyboard()){
            ViewUtils.hideKeyboard(this);
        }

    }

    @Override
    public void onTitleChange(String titleChange) {
        final ActionBar mBar = getSupportActionBar();
        if(mBar != null){
            mBar.setTitle(titleChange);
        }
    }

    @Override
    public void onTitleChange(int resId) {
        final ActionBar mBar = getSupportActionBar();
        if(mBar != null){
            mBar.setTitle(resId);
        }
    }

    @Override
    public void onSubTitleChange(String subTitleChange) {
        final ActionBar mBar = getSupportActionBar();
        if(mBar != null){
            mBar.setSubtitle(subTitleChange);
        }
    }

    @Override
    public void onSubTitleChange(int resId) {
        final ActionBar mBar = getSupportActionBar();
        if(mBar != null){
            mBar.setSubtitle(resId);
        }
    }

    @Override
    public void onBackPressed() {
        if(canGoBack()) {
            super.onBackPressed();
        }else{
            onBackPressedStrict();
        }
    }

    /**
     * ResourceId to be overrided in the subclass activity using the {view}.xml
     * It has a default value of 0, but must be overidden with real xml generated by R.java
     *
     *
     * @return the xml file or the view file in the subclass activity
     */
    @LayoutRes
    protected abstract int resourceId();


    /**
     * CanGoBack flag to be overrided or leave as-is by the user if we want the activity to be strict on going back
     * It has a default value of false, but it isnt necessary to be overidden
     *
     * @return the flag {boolean} if the user can really go back
     */
    protected abstract boolean canGoBack();


    /**
     * onBackPressedStrict to be overrided or leave as-is by the user
     * if we want total control of back button then implement some dialog here
     * If user implemented canGoback strict, then user must implement some messaging mechanism here
     */
    protected abstract void onBackPressedStrict();

    /**
     * fullScreen to be overrided by user
     * Removes the status bar
     * Defaults to false
     * @return the flag {boolean}
     */
    protected abstract boolean fullScreen();

    /**
     * Hides toolbar if true
     * Addresses if we want to optionally hide the toolbar using these flag
     * Defaults to false
     * @return the flag {boolean}
     */
    protected abstract boolean hideToolBar();

    /**
     * Set whether an activity title/subtitle should be displayed.
     *
     * <p>To set several display options at once, see the setDisplayOptions methods.
     *
     * @return displayTitle true to display a title/subtitle if present.
     */

    protected abstract boolean displayTitle();

    /**
     * displayHomeUp if we want to have a arrow / hamburger button / icon
     *     /**
     * Set whether home should be displayed as an "up" affordance.
     * Set this to true if selecting "home" returns up by a single level in your UI
     * rather than back to the top level or front page.
     *
     * <p>To set several display options at once, see the setDisplayOptions methods.
     *
     *
     * @return boolean flag true or false defaults to false
     */
    protected abstract boolean displayHomeUp();

    /**
     * Enable or disable the "home" button in the corner of the action bar. (Note that this
     * is the application home/up affordance on the action bar, not the systemwide home
     * button.)
     *
     * <p>This defaults to true for packages targeting &lt; API 14. For packages targeting
     * API 14 or greater, the application should call this method to enable interaction
     * with the home/up affordance.
     *
     * <p>Setting the {@link #} display option will automatically enable
     * the home button.
     *
     * @return true to enable the home button, false to disable the home button.
     */
    protected abstract boolean homeButton();

    /**
     * Subclass will handle some additional functions to override
     * For example I want to set the initial textView text to "Hello World"
     * Then this is the initial state on onCreate of the activity we should setup
     * @param savedInstanceState
     */
    protected abstract void provideSetUp(Bundle savedInstanceState);

    /**
     * Subclass will handle getting the bundles from previous activity
     * @param savedInstanceState
     */
    protected abstract void provideBundleExtra(Bundle savedInstanceState);


    /**
     * Subclass will handle title for each activity
     * Will be called after each get of bundle extras
     * @return resId of the String title
     */
    protected abstract int provideTitle();

    /**
     * Subclass will handle if we want to hide soft-keyboard on start-up of activity
     * The return value will provide the soft-keyboard to be visible/hidden
     * Default value is false
     * @return true if we want to hide soft-keyboard otherwise false
     */
    protected abstract boolean hideKeyboard();

    /**
     * Subclass will handle the setting the data to this hashmap as this will be called
     * when the view will be If called, this method will occur before onStop().
     * There are no guarantees about whether it will occur before or after onPause().
     * @see this.onSaveInstanceState( Bundle outState)
     * @return the savedinstance hashmap key value pairs of String and Object
     */
    protected abstract HashMap<String, Object> getStates();

    /**
     * Handles back button action
     * @param item
     * @return boolean true or false
     */
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch(item.getItemId()){
            case android.R.id.home:
                onBackPressed();
                return true;
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        Log.d(TAG  , "OnSavedInstanceState");
        HashMap<String, Object> stateList = getStates();
        if(stateList != null) {
            for (Map.Entry<String, Object> entry : stateList.entrySet()) {
                if (entry.getValue() instanceof Integer) {
                    outState.putInt(entry.getKey(), (Integer) entry.getValue());
                } else if (entry.getValue() instanceof Double) {
                    outState.putDouble(entry.getKey(), (Double) entry.getValue());
                } else if (entry.getValue() instanceof String) {
                    outState.putString(entry.getKey(), (String) entry.getValue());
                }
            }
        }
    }
}
